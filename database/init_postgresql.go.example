// +build ignore

// ============================================================================
// PostgreSQL Init - Replace init.go with this file for PostgreSQL support
// ============================================================================
//
// SETUP:
//   1. Rename this file to init.go (backup the SQLite one if needed)
//   2. Update sqlc.yaml: engine: "postgresql"
//   3. Run: sqlc generate
//   4. Run: go mod tidy
//
// RECOMMENDED DRIVER:
//   github.com/lib/pq (most popular, stable)
//   or github.com/jackc/pgx/v5/stdlib (faster, more features)
//
// INSTALL:
//   go get github.com/lib/pq
//
// DSN FORMAT:
//   postgres://user:password@host:port/dbname?sslmode=disable
//   or: host=localhost port=5432 user=myuser password=mypass dbname=mydb sslmode=disable
// ============================================================================

package database

import (
	"context"
	"database/sql"
	_ "embed"
	"fmt"
	"log"
	"sync"

	_ "github.com/lib/pq" // PostgreSQL driver
)

//go:embed schema.sql
var schemaSQL string

// DB holds the database connection and query interface
type DB struct {
	Conn *sql.DB
	Q    *Queries
}

// Global instance
var (
	instance *DB
	once     sync.Once
)

// Config holds database configuration
type Config struct {
	DSN      string // Connection string
	LogLevel string // "silent", "error", "warn", "info"
}

// DefaultConfig returns default PostgreSQL configuration
func DefaultConfig() Config {
	return Config{
		DSN:      "postgres://postgres:postgres@localhost:5432/app?sslmode=disable",
		LogLevel: "error",
	}
}

// Init initializes the database with the given configuration
func Init(cfg Config) (*DB, error) {
	var initErr error

	once.Do(func() {
		conn, err := sql.Open("postgres", cfg.DSN)
		if err != nil {
			initErr = fmt.Errorf("failed to open database: %w", err)
			return
		}

		// Test connection
		if err := conn.Ping(); err != nil {
			initErr = fmt.Errorf("failed to ping database: %w", err)
			return
		}

		// Run schema migrations
		if _, err := conn.ExecContext(context.Background(), schemaSQL); err != nil {
			initErr = fmt.Errorf("failed to run schema migrations: %w", err)
			return
		}

		instance = &DB{
			Conn: conn,
			Q:    New(conn),
		}

		if cfg.LogLevel != "silent" {
			log.Println("PostgreSQL connected successfully!")
		}
	})

	if initErr != nil {
		return nil, initErr
	}

	return instance, nil
}

// MustInit initializes the database and panics on error
func MustInit(cfg Config) *DB {
	db, err := Init(cfg)
	if err != nil {
		log.Fatalf("Database initialization failed: %v", err)
	}
	return db
}

// Get returns the global database instance
func Get() *DB {
	if instance == nil {
		log.Fatal("Database not initialized. Call Init() first.")
	}
	return instance
}

// Close closes the database connection
func Close() error {
	if instance != nil && instance.Conn != nil {
		return instance.Conn.Close()
	}
	return nil
}

// Transaction executes a function within a database transaction
func (db *DB) Transaction(ctx context.Context, fn func(*Queries) error) error {
	tx, err := db.Conn.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	if err := fn(db.Q.WithTx(tx)); err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx error: %v, rollback error: %w", err, rbErr)
		}
		return err
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}
