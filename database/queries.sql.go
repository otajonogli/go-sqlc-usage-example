// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const addToUserGroupBalance = `-- name: AddToUserGroupBalance :exec
UPDATE user_group 
SET balance = balance + ? 
WHERE user_telegram_id = ? AND group_telegram_id = ?
`

type AddToUserGroupBalanceParams struct {
	Balance         sql.NullFloat64 `json:"balance"`
	UserTelegramID  int64           `json:"user_telegram_id"`
	GroupTelegramID int64           `json:"group_telegram_id"`
}

func (q *Queries) AddToUserGroupBalance(ctx context.Context, arg AddToUserGroupBalanceParams) error {
	_, err := q.db.ExecContext(ctx, addToUserGroupBalance, arg.Balance, arg.UserTelegramID, arg.GroupTelegramID)
	return err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (telegram_id, title)
VALUES (?, ?)
RETURNING id, balance, telegram_id, title, url, created_at, updated_at
`

type CreateGroupParams struct {
	TelegramID int64          `json:"telegram_id"`
	Title      sql.NullString `json:"title"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.TelegramID, arg.Title)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Balance,
		&i.TelegramID,
		&i.Title,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    telegram_id, first_name, username, status, language, refer_from_id
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at
`

type CreateUserParams struct {
	TelegramID  int64          `json:"telegram_id"`
	FirstName   string         `json:"first_name"`
	Username    sql.NullString `json:"username"`
	Status      string         `json:"status"`
	Language    string         `json:"language"`
	ReferFromID sql.NullInt64  `json:"refer_from_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.TelegramID,
		arg.FirstName,
		arg.Username,
		arg.Status,
		arg.Language,
		arg.ReferFromID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.FirstName,
		&i.Username,
		&i.BalanceGame,
		&i.BalanceChats,
		&i.Status,
		&i.Language,
		&i.ReferFromID,
		&i.LastStreakClaimAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserGroup = `-- name: CreateUserGroup :one
INSERT INTO user_group (user_telegram_id, group_telegram_id, balance)
VALUES (?, ?, 0)
RETURNING id, user_telegram_id, group_telegram_id, balance
`

type CreateUserGroupParams struct {
	UserTelegramID  int64 `json:"user_telegram_id"`
	GroupTelegramID int64 `json:"group_telegram_id"`
}

func (q *Queries) CreateUserGroup(ctx context.Context, arg CreateUserGroupParams) (UserGroup, error) {
	row := q.db.QueryRowContext(ctx, createUserGroup, arg.UserTelegramID, arg.GroupTelegramID)
	var i UserGroup
	err := row.Scan(
		&i.ID,
		&i.UserTelegramID,
		&i.GroupTelegramID,
		&i.Balance,
	)
	return i, err
}

const getGroupByTelegramID = `-- name: GetGroupByTelegramID :one

SELECT id, balance, telegram_id, title, url, created_at, updated_at FROM groups WHERE telegram_id = ? LIMIT 1
`

// =====================
// GROUP QUERIES
// =====================
func (q *Queries) GetGroupByTelegramID(ctx context.Context, telegramID int64) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupByTelegramID, telegramID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Balance,
		&i.TelegramID,
		&i.Title,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrCreateUserGroup = `-- name: GetOrCreateUserGroup :one
INSERT INTO user_group (user_telegram_id, group_telegram_id, balance)
VALUES (?, ?, 0)
ON CONFLICT(user_telegram_id, group_telegram_id) DO UPDATE SET
    balance = user_group.balance
RETURNING id, user_telegram_id, group_telegram_id, balance
`

type GetOrCreateUserGroupParams struct {
	UserTelegramID  int64 `json:"user_telegram_id"`
	GroupTelegramID int64 `json:"group_telegram_id"`
}

func (q *Queries) GetOrCreateUserGroup(ctx context.Context, arg GetOrCreateUserGroupParams) (UserGroup, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateUserGroup, arg.UserTelegramID, arg.GroupTelegramID)
	var i UserGroup
	err := row.Scan(
		&i.ID,
		&i.UserTelegramID,
		&i.GroupTelegramID,
		&i.Balance,
	)
	return i, err
}

const getTopGroupsForUser = `-- name: GetTopGroupsForUser :many
SELECT 
    g.title,
    ug.balance
FROM user_group ug
LEFT JOIN groups g ON g.telegram_id = ug.group_telegram_id
WHERE ug.user_telegram_id = ?
ORDER BY ug.balance DESC
LIMIT 10
`

type GetTopGroupsForUserRow struct {
	Title   sql.NullString  `json:"title"`
	Balance sql.NullFloat64 `json:"balance"`
}

func (q *Queries) GetTopGroupsForUser(ctx context.Context, userTelegramID int64) ([]GetTopGroupsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopGroupsForUser, userTelegramID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopGroupsForUserRow{}
	for rows.Next() {
		var i GetTopGroupsForUserRow
		if err := rows.Scan(&i.Title, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsersByBalance = `-- name: GetTopUsersByBalance :many
SELECT id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at FROM users 
ORDER BY (balance_game + balance_chats) DESC 
LIMIT ?
`

func (q *Queries) GetTopUsersByBalance(ctx context.Context, limit int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getTopUsersByBalance, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.FirstName,
			&i.Username,
			&i.BalanceGame,
			&i.BalanceChats,
			&i.Status,
			&i.Language,
			&i.ReferFromID,
			&i.LastStreakClaimAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsersInGroup = `-- name: GetTopUsersInGroup :many

SELECT 
    u.first_name,
    u.username,
    ug.balance
FROM user_group ug
LEFT JOIN users u ON u.telegram_id = ug.user_telegram_id
WHERE ug.group_telegram_id = ?
ORDER BY ug.balance DESC
LIMIT 10
`

type GetTopUsersInGroupRow struct {
	FirstName sql.NullString  `json:"first_name"`
	Username  sql.NullString  `json:"username"`
	Balance   sql.NullFloat64 `json:"balance"`
}

// =====================
// STATS QUERIES
// =====================
func (q *Queries) GetTopUsersInGroup(ctx context.Context, groupTelegramID int64) ([]GetTopUsersInGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopUsersInGroup, groupTelegramID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopUsersInGroupRow{}
	for rows.Next() {
		var i GetTopUsersInGroupRow
		if err := rows.Scan(&i.FirstName, &i.Username, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalGroupBalance = `-- name: GetTotalGroupBalance :one
SELECT COALESCE(SUM(balance), 0) AS total FROM user_group 
WHERE group_telegram_id = ?
`

func (q *Queries) GetTotalGroupBalance(ctx context.Context, groupTelegramID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalGroupBalance, groupTelegramID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getTotalUserBalance = `-- name: GetTotalUserBalance :one
SELECT COALESCE(SUM(balance), 0) AS total FROM user_group 
WHERE user_telegram_id = ?
`

func (q *Queries) GetTotalUserBalance(ctx context.Context, userTelegramID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalUserBalance, userTelegramID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.FirstName,
		&i.Username,
		&i.BalanceGame,
		&i.BalanceChats,
		&i.Status,
		&i.Language,
		&i.ReferFromID,
		&i.LastStreakClaimAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByTelegramID = `-- name: GetUserByTelegramID :one

SELECT id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at FROM users WHERE telegram_id = ? LIMIT 1
`

// =====================
// USER QUERIES
// =====================
func (q *Queries) GetUserByTelegramID(ctx context.Context, telegramID int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByTelegramID, telegramID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.FirstName,
		&i.Username,
		&i.BalanceGame,
		&i.BalanceChats,
		&i.Status,
		&i.Language,
		&i.ReferFromID,
		&i.LastStreakClaimAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGroup = `-- name: GetUserGroup :one

SELECT id, user_telegram_id, group_telegram_id, balance FROM user_group 
WHERE user_telegram_id = ? AND group_telegram_id = ? 
LIMIT 1
`

type GetUserGroupParams struct {
	UserTelegramID  int64 `json:"user_telegram_id"`
	GroupTelegramID int64 `json:"group_telegram_id"`
}

// =====================
// USER-GROUP QUERIES
// =====================
func (q *Queries) GetUserGroup(ctx context.Context, arg GetUserGroupParams) (UserGroup, error) {
	row := q.db.QueryRowContext(ctx, getUserGroup, arg.UserTelegramID, arg.GroupTelegramID)
	var i UserGroup
	err := row.Scan(
		&i.ID,
		&i.UserTelegramID,
		&i.GroupTelegramID,
		&i.Balance,
	)
	return i, err
}

const getUserPosition = `-- name: GetUserPosition :one
SELECT COUNT(*) + 1 AS position FROM users 
WHERE (balance_game + balance_chats) > ?
`

func (q *Queries) GetUserPosition(ctx context.Context, balanceGame sql.NullFloat64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserPosition, balanceGame)
	var position int64
	err := row.Scan(&position)
	return position, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET first_name = ?, username = ?, updated_at = CURRENT_TIMESTAMP
WHERE telegram_id = ?
RETURNING id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at
`

type UpdateUserParams struct {
	FirstName  string         `json:"first_name"`
	Username   sql.NullString `json:"username"`
	TelegramID int64          `json:"telegram_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.FirstName, arg.Username, arg.TelegramID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.FirstName,
		&i.Username,
		&i.BalanceGame,
		&i.BalanceChats,
		&i.Status,
		&i.Language,
		&i.ReferFromID,
		&i.LastStreakClaimAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserBalanceChats = `-- name: UpdateUserBalanceChats :exec
UPDATE users 
SET balance_chats = ?, updated_at = CURRENT_TIMESTAMP
WHERE telegram_id = ?
`

type UpdateUserBalanceChatsParams struct {
	BalanceChats sql.NullFloat64 `json:"balance_chats"`
	TelegramID   int64           `json:"telegram_id"`
}

func (q *Queries) UpdateUserBalanceChats(ctx context.Context, arg UpdateUserBalanceChatsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserBalanceChats, arg.BalanceChats, arg.TelegramID)
	return err
}

const updateUserGroupBalance = `-- name: UpdateUserGroupBalance :exec
UPDATE user_group 
SET balance = ? 
WHERE user_telegram_id = ? AND group_telegram_id = ?
`

type UpdateUserGroupBalanceParams struct {
	Balance         sql.NullFloat64 `json:"balance"`
	UserTelegramID  int64           `json:"user_telegram_id"`
	GroupTelegramID int64           `json:"group_telegram_id"`
}

func (q *Queries) UpdateUserGroupBalance(ctx context.Context, arg UpdateUserGroupBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateUserGroupBalance, arg.Balance, arg.UserTelegramID, arg.GroupTelegramID)
	return err
}

const upsertGroup = `-- name: UpsertGroup :one
INSERT INTO groups (telegram_id, title)
VALUES (?, ?)
ON CONFLICT(telegram_id) DO UPDATE SET
    title = CASE WHEN excluded.title != '' THEN excluded.title ELSE groups.title END,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, balance, telegram_id, title, url, created_at, updated_at
`

type UpsertGroupParams struct {
	TelegramID int64          `json:"telegram_id"`
	Title      sql.NullString `json:"title"`
}

func (q *Queries) UpsertGroup(ctx context.Context, arg UpsertGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, upsertGroup, arg.TelegramID, arg.Title)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Balance,
		&i.TelegramID,
		&i.Title,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (telegram_id, first_name, username, status, language)
VALUES (?, ?, ?, 'active', 'en')
ON CONFLICT(telegram_id) DO UPDATE SET
    first_name = CASE WHEN excluded.first_name != '' THEN excluded.first_name ELSE users.first_name END,
    username = CASE WHEN excluded.username != '' THEN excluded.username ELSE users.username END,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, telegram_id, first_name, username, balance_game, balance_chats, status, language, refer_from_id, last_streak_claim_at, created_at, updated_at
`

type UpsertUserParams struct {
	TelegramID int64          `json:"telegram_id"`
	FirstName  string         `json:"first_name"`
	Username   sql.NullString `json:"username"`
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser, arg.TelegramID, arg.FirstName, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.FirstName,
		&i.Username,
		&i.BalanceGame,
		&i.BalanceChats,
		&i.Status,
		&i.Language,
		&i.ReferFromID,
		&i.LastStreakClaimAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
